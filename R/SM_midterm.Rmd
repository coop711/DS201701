---
title: "SM Midterm 201701"
author: "coop711"
date: "`r Sys.Date()`"
output: html_document
---

#### Data 

#### Excel 자료 읽어들이기 

* excel 파일을 잘 읽어들이는 `xlsx` 패키지를 올려놓고, 자료구조에 맞춰 argument 설정.
    * Sheet 번호, startRow, colIndex, header 의 용도 파악. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(xlsx)
library(pander)
library(knitr)
panderOptions('table.split.table', Inf)
panderOptions('table.alignment.rownames', 'left')
panderOptions('table.alignment.default', 'right')
options(width=180)
# panderOptions('digits', 3)
```

```{r, read data, echo = TRUE, results = 'markup'}
midterm.roll <- read.xlsx("../data/SM_midterm.xlsx", 1, startRow = 3, endRow  = 32, colIndex = c(3:7, 9:42), colClasses = c(rep("character", 39)), header = FALSE, stringsAsFactors = FALSE)
names(midterm.roll) <- c("dept", "id", "name", "year", "e.mail", "cell.no", paste("Q", 1:33, sep = ""))
kable(head(midterm.roll[, 1:6]))
kable(head(midterm.roll[, 7:23]))
kable(head(midterm.roll[, 24:39]))
str(midterm.roll)
midterm <- midterm.roll[, c(7:39)]
kable(midterm[1:16])
kable(midterm[17:33])
```

### Q4 수정

`data.frame(...)`의 구실은 무엇인지 생각해 볼 것.

```{r, Q4}
midterm$Q4 <- tolower(midterm$Q4)
na.index <- which(is.na(midterm$Q4))
midterm$Q4[na.index] <- "9999"
q4.split <- sapply(midterm$Q4, function(x) unlist(strsplit(x, split = "")))
Q4_m <- t(q4.split)
rownames(Q4_m) <- NULL
colnames(Q4_m) <- paste("Q4", 1:4, sep = ".")
Q4_m[Q4_m == "9"] <- NA
Q4_m <- lapply(data.frame(Q4_m), factor, levels = c("a", "b", "c", "d"))
str(Q4_m)
```

### `factor` 변환

```{r}
midterm[, c(1:3, 5:33)] <- lapply(midterm[, c(1:3, 5:33)], factor, levels = 1:4, labels = c("가", "나", "다", "라"))
str(midterm)
SM_midterm <- data.frame(midterm[, 1:3], Q4_m, midterm[, -(1:4)], row.names = NULL, stringsAsFactors = FALSE)
str(SM_midterm)
```

### 답안 분포

```{r, pander midterm, echo = TRUE}
kable(SM_midterm[1:18])
kable(SM_midterm[19:36])
pander(t(sapply(SM_midterm, table)))
```

### barplot

```{r, fig.width = 6, fig.height = 12}
par(family = "HCR Dotum LVT", mar = c(5.1, 4.1, 4.1, 8.1))
SM_midterm.tbl <- sapply(SM_midterm, table, useNA = "no")
str(SM_midterm.tbl)
SM_midterm.ptbl <- round(apply(SM_midterm.tbl, 2, prop.table) * 100, digits = 0)
SM_midterm.ptbl
label.ptbl <- matrix(paste(format(SM_midterm.ptbl, digits = 2, nsmall = 0), "%", sep =""), nrow = 4)
label.ptbl <- ifelse(label.ptbl == "  0%", "", label.ptbl)
label.ptbl[, 1:10]
kable(SM_midterm.tbl)
b <- barplot(matrix(SM_midterm.tbl, nrow = 4), horiz = TRUE, axes = FALSE, col = rainbow(4), names.arg = colnames(SM_midterm.tbl), las = 1, xpd = TRUE, legend.text = rownames(SM_midterm.tbl), args.legend = list(x = 35, y = 42))
max(b)
SM_midterm.tbl[1, ]
text(x = SM_midterm.tbl[1, ] / 2, y = b, labels = label.ptbl[1, ])
text(x = SM_midterm.tbl[1, ] + SM_midterm.tbl[2, ] / 2 , y = b, labels = label.ptbl[2, ])
text(x = SM_midterm.tbl[1, ] + SM_midterm.tbl[2, ] + SM_midterm.tbl[3, ] / 2, y = b, labels = label.ptbl[3, ])
text(x = SM_midterm.tbl[1, ] + SM_midterm.tbl[2, ] + SM_midterm.tbl[3, ] + SM_midterm.tbl[4, ]/ 2, y = b, labels = label.ptbl[4, ])
```

#### ggplot

```{r, df}
library(ggplot2)
g0 <- ggplot(data = SM_midterm, mapping = )
```

#### 점수

* 정답 맞춰보기
    * 정답 읽어들이기. `what = ""`로 설정하여 `char`취급. 

```{r, read ans, echo = TRUE, results = 'markup'}
(ans <- scan("../data/SM_ans.txt", what = ""))
```

<!--* 각 학생들의 답안과 맞춰보기 위하여 정답표 작성.
    * 문항별로 정답과 비교하기 위하여 각 문항을 리스트의 원소로 분리
    * `split()` 의 기능과 한계에 유의. `factor` 성격으로부터 `1, 10, 11, ..., 2, 20, ..., 3, 4, 5, ... , 9`로 순서를 잡게 되므로 다시 한번 정리할 필요.
-->
    
    
```{r, ans list and unlist, echo = TRUE, results = 'markup'}
(ans.l <- split(ans, f = paste("A", c(1:3, paste(4, 1:4, sep = "."), 5:33), sep = "")))
(ans.l.2 <- ans.l[paste("A", c(1:3, paste(4, 1:4, sep = "."), 5:33), sep = "")])
```

##### 정답과 대조하여 R(Right)/W(Wrong) 표시 
    
<!--* 채점표라는 의미의 `midterm.marks` 로 저장, (# 표시한 방식으로는 작동하지 않음)-->
    
```{r, marks, echo = TRUE}
# 첫 세 학생의 응답을 기초로 확대, mapply()의 활용 방식에 유의
midterm.marks.rw.q1_3 <- mapply(function(x, y) factor(ifelse(x == y, "R", "W")), y = ans.l.2[1:3], SM_midterm[, 1:3])
midterm.marks.rw <- mapply(function(x, y) factor(ifelse(x == y, "R", "W")), y = ans.l.2, SM_midterm)
# midterm.marks.rw <- mapply(function(x, y = ans.l.2) factor(ifelse(x == y, "R", "W")), midterm[, -26])
# midterm.marks.rw <- sapply(midterm[, -26], function(x, y = ans.l.2) factor(ifelse(x == y, "R", "W")))
pander(midterm.marks.rw)
```
<P style = "page-break-before:always">

##### 학생별 점수 산출

<!--+ 정답을 집계하기 위하여 "R" 갯수를 다시 산출하는 `ifelse()` 적용.
    + 4점씩 곱하면 100점 만점 기준의 점수가 됨. 
    + 조사표는 작성해서 제출했지만 빈칸이 있는 경우는 그 문항을 0점 처리, 결석의 경우는 점수가 모두 0으로 나오는 경우를  NA처리 
-->

```{r, sum of rights answers, echo = TRUE, results = 'markup'}
midterm.marks <- ifelse(midterm.marks.rw == "R", 1, 0)
pander(midterm.marks)
score <- c(rep(3, 3), rep(1, 4), rep(3, 29))
midterm.score <- midterm.marks %*% score
pander(data.frame(학번 = midterm.roll$id, 점수 = midterm.score))
# midterm.score <- apply(midterm.marks, 1, sum, na.rm = TRUE) * 4
# midterm.score[midterm.score == 0] <- NA
which(midterm.score < 60)
```

```{r, pander score, echo = TRUE}
# pander(midterm.score)
```

<!--
<P style = "page-break-before:always">


<!--##### 문항별 정답률-->

<!--* 결석한 경우와 일부 문항에 답을 내지 않은 경우를 구분하는 것이 핵심.
    + `midterm.marks`를 그대로 이용하면 쉽게 계산되나, `is.na`학습 목적으로 `midterm.mark.rw`에서 출발
    + 모든 문항에 NA로 답한 결석한 학생들의 인덱스를 먼저 찾아내고,
-->

```{r, NA management, echo = TRUE, results = 'markup'}
apply(midterm.marks.rw, 1, function(x) all(is.na(x)))
na.all <- which(apply(midterm.marks.rw, 1, function(x) all(is.na(x))))
```

<!--* 정답률 계산
    + NA를 모두 오답처리한 후, 결석한 학생들만 다시 NA로 정정.
    + TRUE의 갯수를 합하여 평균. 
-->

```{r, computing correct answer rates, echo = TRUE, results = 'markup'}
midterm.marks.2 <- midterm.marks.rw
midterm.marks.2[is.na(midterm.marks.2)] <- "W"
midterm.marks.2[na.all, ] <- NA
midterm.marks.2 <- ifelse(midterm.marks.2 == "R", 1, 0)
rate.by.item <- apply(midterm.marks.2, 2, mean, na.rm = TRUE)*100
str(rate.by.item)
rate.by.item <- as.matrix(rate.by.item, 25)
dimnames(rate.by.item) <- list("문항" =  paste("문", c(1:3, paste(4, 1:4, sep = "."), 5:33), sep = ""), "정답률" = "정답률")
# colnames(rate.by.item) <- "정답률"
```

<!--
```{r, correct answer rates, echo = TRUE}
pander(rate.by.item, digits = 3)
```
-->

<!--* `replace()`를 이용하면, 

```{r}
(midterm.marks.3 <- replace(midterm.marks.rw, is.na(midterm.marks.rw), "W"))
midterm.marks.3[na.all, ] <- NA
midterm.marks.3
```
-->

<!--<P style = "page-break-before:always">-->

#### 어려운 문제?

##### 정답률 80% 이하

```{r, hardest question below 80, echo = TRUE}
pander(rate.by.item[which(rate.by.item <= 80), ])
```

##### 정답률 70% 이하

```{r, hardest question below 70, echo = TRUE}
pander(rate.by.item[which(rate.by.item <= 70), ])
```

##### 정답률 60% 이하

```{r, hardest question below 60, echo = TRUE}
pander(t(rate.by.item[which(rate.by.item <= 60), , drop = FALSE]))
```

##### 정답률 50% 이하

```{r, hardest question below 50, echo = TRUE}
pander(t(rate.by.item[which(rate.by.item <= 50), , drop = FALSE]))
```

##### 정답률 40% 이하

```{r, hardest question below 40, echo = TRUE}
pander(t(rate.by.item[which(rate.by.item <= 40), , drop = FALSE]))
```

##### 정답률 30% 이하

```{r, hardest question below 30, echo = TRUE}
pander(t(rate.by.item[which(rate.by.item <= 30), , drop = FALSE]))
```


<!--## Data 정리

```{r}
save.image("SM_midterm.RData")
```
-->
